package goa

import (
	"fmt"
	"io"
	"log"
	"net/http"
	"net/url"
	"os"
	"strings"

	"github.com/codegangsta/negroni"
	"github.com/gorilla/mux"
)

// Public interface of a goa application.
// A goa application consists of a set of handlers that get mounted under a
// given base path via the `MountHandler` method.
// Goa applications are created with the `New()` factory function. They can be
// run directly using the `ServeHTTP()` method or as a Negroni middleware using
// the `AsMiddleware()` method (see https://github.com/codegangsta/negroni).
// All routes mounted on an application can be retrieved using the `Routes()`
// method and the `WriteRaml()` method generates its RAML representation.
type Application interface {
	// Add handler to application
	MountHandler(method, path string, handler http.HandlerFunc)
	// ServeHTTP() implements http.HandlerFunc
	ServeHTTP(http.ResponseWriter, *http.Request)
	// AsMiddleware() returns a Negroni handler that wraps the application
	AsMiddleware() negroni.Handler
	// Routes returns the application route map
	Routes() *RouteMap
	// Generate RAML representation for the API (http://raml.org)
	WriteRaml(io.Writer)
}

// New creates a new goa application given a base path and an optional set of
// Negroni handlers (middleware).
func New(basePath string, handlers ...negroni.Handler) Application {
	router := mux.NewRouter()
	var n *negroni.Negroni
	if len(handlers) == 0 {
		// Default handlers a la "Negroni Classic()"
		logger := &negroni.Logger{log.New(os.Stdout, "[goa] ",
			log.Ldate|log.Lmicroseconds)}
		n = negroni.New(negroni.NewRecovery(), logger,
			negroni.NewStatic(http.Dir("public")))
	} else {
		// Custom handlers
		n = negroni.New(handlers...)
	}
	a := &app{
		router:    router,
		basePath:  basePath,
		routeMap:  newRouteMap(basePath),
		resources: make(map[string]*ResourceDefinition),
		n:         n,
	}
	n.Use(a.AsMiddleware())
	return a
}

// MountResource mounts a resource under its route prefix.
// This registers all the resource action handlers under the corresponding
// action path
// This function is called by the code generated by the goa command line tool.
func (app *app) MountResource(r *ResourceDefinition) error {
	app.resources[r.Name] = r
	var path string
	if len(r.RoutePrefix) > 0 {
		url, err := url.Parse(r.RoutePrefix)
		if err != nil {
			return fmt.Errorf("Invalid route prefix '%s' (%s)", r.RoutePrefix, err.Error())
		}
		if len(url.RawQuery) > 0 {
			return fmt.Errorf("Invalid route prefix '%s' (route prefix cannot have a query string)")
		}
		path = url.Path
	}
	router := app.router.Path(path)
	for n, a := range r.Actions {
		if err := app.mountAction(a.Method, a.Path, router, a.Handler); err != nil {
			return err
		}
	}
}

// ServeHTTP dispatches the handler registered in the matched route.
func (app *app) ServeHTTP(w http.ResponseWriter, req *http.Request) {
	app.n.ServeHTTP(w, req)
}

// AsMiddleware() returns a negroni handler/middleware that runs the application
func (app *app) AsMiddleware() negroni.Handler {
	return negroni.Wrap(app.router)
}

// PrintRoutes prints application routes to stdout
func (app *app) Routes() *RouteMap {
	return app.routeMap
}

// WriteRaml returns the RAML representation of the API
// see http://raml.org
func (app *app) WriteRaml() string {
	return ""
}

// Mount a single resource action
func (app *app) mountAction(verb, path string, router mux.Router, handler http.HandlerFunc) error {
	if len(path) > 0 {
		url, err := url.Parse(path)
		if err != nil {
			return fmt.Errorf("Invalid handler path '%s' (%s)", path, err.Error())
		}
		path = url.Path
	}
	verb = strings.ToUpper(verb)
	matcher := router.Methods(verb).Path(path)
	matcher.HandlerFunc(handler)
}

// Internal struct holding application data
// Implements the Application interface
type app struct {
	router    *mux.Router
	basePath  string
	resources []ResourceDefinition
	routeMap  *RouteMap
	n         *negroni.Negroni
	resources map[string]*ResourceDefinition
}
